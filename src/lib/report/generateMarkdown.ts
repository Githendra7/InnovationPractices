import {
    GraphState
} from '@/lib/langgraph/types';
// We might need to fetch the raw JSONs from DB and cast them to types.

export function generateMarkdown(projectTitle: string, ideaText: string, outputs: any[], domain?: string | null): string {
    // outputs is array of WorkflowOutput objects (with jsonOutput and userEdits)
    // We need to merge them into a cohesive view.
    // Prefer userEdits over jsonOutput.

    const getStageData = (stage: string) => {
        const out = outputs.find(o => o.stage === stage);
        if (!out) return null;
        return out.userEdits || out.jsonOutput;
    };

    const intake = getStageData('INTAKE');
    const functional = getStageData('FUNCTIONAL');
    const morphological = getStageData('MORPHOLOGICAL');
    const risks = getStageData('RISKS');
    const final = getStageData('FINAL');

    let md = `# ${projectTitle}\n\n`;
    if (domain) md += `**Domain:** ${domain}\n\n`;
    md += `## Original Idea\n${ideaText}\n\n`;

    if (intake) {
        md += `## 1. Problem Definition & Objectives\n\n`;
        md += `**Refined Idea:** ${intake.cleanedIdea}\n\n`;
        md += `### Objectives\n${intake.objectives?.map((o: string) => `- ${o}`).join('\n')}\n\n`;
        md += `### Constraints\n${intake.constraints?.map((c: string) => `- ${c}`).join('\n')}\n\n`;
        md += `### Assumptions\n${intake.assumptions?.map((a: string) => `- ${a}`).join('\n')}\n\n`;
    }

    if (functional) {
        md += `## 2. Functional Decomposition\n\n`;
        md += `**Overall Function:** ${functional.overallFunction}\n\n`;
        md += `### Sub-Functions\n`;
        functional.subFunctions?.forEach((sf: any) => {
            md += `- **${sf.function}**: ${sf.description}\n`;
        });
        md += `\n`;
    }

    if (morphological) {
        md += `## 3. Morphological Chart\n\n`;
        md += `| Sub-Function | Option 1 | Option 2 | Option 3 | Option 4 | Option 5 |\n`;
        md += `| --- | --- | --- | --- | --- | --- |\n`;

        morphological.functionAlternatives?.forEach((fa: any) => {
            const alts = fa.alternatives?.map((a: any) => a.option) || [];
            // Pad to 5 or strictly format
            const row = [fa.function, ...alts];
            md += `| ${row.join(' | ')} |\n`;
        });
        md += `\n`;
    }

    if (risks) {
        md += `## 4. Risk & Trade-off Analysis\n\n`;
        md += `### Key Risks\n`;
        risks.risks?.forEach((r: any) => {
            md += `- **${r.category}:** ${r.risk} (Mitigation: ${r.mitigation})\n`;
        });
        md += `\n### Trade-offs\n`;
        risks.tradeoffs?.forEach((t: any) => {
            md += `- **${t.decision}:** ${t.optionA} vs ${t.optionB}. Note: ${t.notes}\n`;
        });
        md += `\n`;
    }

    if (final) {
        md += `## 5. Summary & Next Steps\n\n`;
        md += `${final.summary}\n\n`;
        md += `### Recommended Next Steps\n`;
        final.recommendedNextSteps?.forEach((s: string) => {
            md += `- ${s}\n`;
        });
        md += `\n`;
    }

    md += `\n---\nGenerated by AI Innovation Tool`;

    return md;
}
